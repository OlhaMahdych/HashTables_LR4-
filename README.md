
# Лабораторна робота №4
**Дисципліна:** Теорія алгоритмів  
**Тема:** Робота з хеш-таблицями  
**Варіант:** №24  
**Послідовність:** У долі чужої руки довгі, а в своєї — короткі  

## Виконав
Студент групи ЕАІ-244  
Магдич О.В.  

**Перевірили:**  
Смик С. Ю., Арсірій О.О.  

**Місце та рік:** Одеса, 2025  


## Мета роботи
Набуття практичних навичок із проектування, реалізації, тестування та аналізу алгоритмів створення і обробки хеш-таблиць.


## Завдання
1. Спроектувати, реалізувати, протестувати та проаналізувати алгоритм створення відкритої хеш-таблиці з хешуванням за ланцюжками, використовуючи хеш-функції:
   - Метод ділення: `h(K) = K mod 13`
   - Метод множення: `h(K) = ⌊16 * (K*A mod 1)⌋`
2. Виконати візуалізацію створення відкритої хеш-таблиці та надати пояснення.
3. Спроектувати, реалізувати, протестувати та проаналізувати алгоритм створення закритої хеш-таблиці з відкритою адресацією.
4. Виконати візуалізацію закритої хеш-таблиці та надати пояснення.
5. Показати ефективність хешування з ланцюжками та з відкритою адресацією, порівняти обчислювальну складність сортування купою та швидкого сортування, визначити максимальну та середню кількість порівнянь.


## Варіанти завдань
**Вхідні дані (варіант №24):**  
"У долі чужої руки довгі, а в своєї — короткі."

## Основні кроки роботи

### 1. Відкрита хеш-таблиця (ланцюжки)
- Створюється масив `m` порожніх списків.
- Для кожного ключа обчислюється хеш і додається у відповідний список.
- Колізії формують ланцюжки.

**Псевдокод:**
```text
procedure CreateHashTableChaining(A, hash_func, m)
    table := array[0..m-1] of empty lists
    for each key in A do
         index := hash_func(key)
         append key to table[index]
    return table
````

**Python-код:**
(приклад з використанням методу ділення та множення)

```python
def hash_division(key, m=13):
    return key % m

def hash_multiplication(key, m=16, A=0.618):
    return int(m * ((key * A) % 1))

def create_hash_table_chaining(keys, hash_func, m):
    table = [[] for _ in range(m)]
    for key in keys:
        index = hash_func(key, m)
        table[index].append(key)
    return table

sequence = [ord(c) for c in "У долі чужої руки довгі, а в своєї — короткі."]
table_div = create_hash_table_chaining(sequence, hash_division, 13)
table_mul = create_hash_table_chaining(sequence, hash_multiplication, 16)
```

### 2. Закрита хеш-таблиця (відкрита адресація)

* Колізії вирішуються методом лінійного пробування:
  `hi(k) = (h(k) + i) mod m`

**Псевдокод:**

```text
procedure CreateHashTableOpenAddressing(A, hash_func, m)
    table := array[0..m-1] of None
    for key in A do
         i := 0
         index := hash_func(key)
         while table[(index + i) mod m] is not empty do
              i := i + 1
         table[(index + i) mod m] := key
    return table
```

**Python-код:**

```python
def create_hash_table_open(keys, hash_func, m):
    table = [None] * m
    for key in keys:
        index = hash_func(key, m)
        i = 0
        while table[(index + i) % m] is not None:
            i += 1
        table[(index + i) % m] = key
    return table
```

### 3. Аналіз ефективності

* Визначено максимальну та середню кількість порівнянь для пошуку елементів.
* Відкрита таблиця з ланцюжками показала меншу середню кількість порівнянь.
* Закрита таблиця демонструє кластеризацію, що збільшує максимальну кількість порівнянь.

### 4. Порівняння сортувань

| Алгоритм   | Середня складність | Порівнянь | Присвоєнь | Особливості |
| ---------- | ------------------ | --------- | --------- | ----------- |
| Heap Sort  | O(n log n)         | середнє   | середнє   | нестійкий   |
| Quick Sort | O(n log n)         | менше     | менше     | нестійкий   |


## Висновки

* Ознайомлено з методами побудови хеш-таблиць та обробки колізій.
* Відкрита таблиця з ланцюжками ефективніша для пошуку в середньому.
* Закрита таблиця демонструє кластеризацію.
* Heap Sort та Quick Sort нестійкі, але Quick Sort виконує менше базових операцій.
* Лабораторна робота дала практичні навички проектування, реалізації та аналізу алгоритмів хешування.
